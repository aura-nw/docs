---
sidebar_position: 2
sidebar_label: Create Project
title: Create a CW-721 dApp Project
---

import {DocCard} from '@site/src/components/Cards/Cards.js';

<DocCard>
  <p>
    We will show you how to create the CW-721 project and begin modifying the contract state.
  </p>
  <ul>
    <li><a href="#prerequisites">Prerequisites</a></li>
    <li><a href="#create-project">Creating Project</a></li>
    <li><a href="#state">Working on the State</a></li>
  </ul>
</DocCard>


:::info
You can find the source code for this project at the [cw721-repository](https://github.com/aura-nw/tutorial_source/tree/main/cw721-dapp).
:::

## Prerequisites
:::note
This guide assumes that you have already set up your development environment. If you have not done so, please check out the [Environment Setup](../../getting-started/env-setup) section.
:::

To complete this tutorial successfully, you'll need:

- Beaker toolchain.
- An Aura account.
- NFT Storage Account.

If you followed the documentation you should be familiar with `Beaker` and know how to create an Aura account. For this particular tutorial we will be using **NFT Storage.** Instead of storing NFT images in public storage services such as Google Drive, Imgur, OneDrive, etc. we will use a third party service to store NFT images in a decentralized manner using [IPFS](https://docs.ipfs.tech/concepts/what-is-ipfs/). You can use a free service such as [NFT Storage](https://nft.storage/#getting-started). 

## Create project
Now we can begin with our project. Let's use beaker to create a new project named `cw721-dapp`:

```bash
beaker new cw721-dapp
```

Just as we did with the `cw-20` tutorial, select the `minimal` template once the prompt asks you to select the template type:
```
? ü§∑   Which starting template would you like to use? 
‚ùØ  minimal
  counter-example
```

Now we have a minimal project setup. But there is nothing contracts yet. To do that, let's create our contract `cw721-factory`:

```bash
cd cw721-dapp
beaker wasm new cw721-factory
```

Now, the files for this contract can be found in `contracts/cw721-factory`. 

## State
We will start writing the contract code in the `src/state.rs` file. Upon opening it you should see something similar to the following:

```rust title=src/state.rs
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use cosmwasm_std::Addr;
use cw_storage_plus::Item;

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct State {
    pub count: i32,
    pub owner: Addr,
}

pub const STATE: Item<State> = Item::new("state");
```

Let's talk through this section by section.

The first 5 lines of code are importing other structs, interfaces and functions from other packages. To give a quick overview without getting bogged down too much:

-   JsonSchema allows structs to be serialized and deserialized to and from JSON.
-   Deserialize and Serialize provide the serialization described above.
-   Addr is a Cosmos-like address, under the hood it is simply a string with some pattern checks.
-   Item is a helper provided by storage plus. It effectively means we can store an item in storage. In this case, the `STATE` variable is an `Item` that stores a singular `State` struct.

We want to make some changes to this, let's rename it so that it's easier to understand. Let's name our global state `Config` as it is the general configuration of our contract. 
1. Remove the `count` and `owner` variable from the struct and rename it to `Config`. 
2. Then rename `STATE` to `CONFIG`.

It should look like this:

```rust title=src/state.rs
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use cosmwasm_std::Addr;
use cw_storage_plus::Item;

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct Config {

}

pub const CONFIG: Item<Config> = Item::new("config");
```

Now let's think about what global configs we want, we probably want an NFT Minter Contract that can mint some amazing NFTs for buyer with fixed price fee. 

Let's add some necessary fields representing the configuration parameters of our NFT minter contract.

```rust title=src/state.rs
// ...

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct Config {
    pub owner: Addr,
    pub cw20_address: Addr,
    pub cw721_address: Option<Addr>,
    pub max_tokens: u32,
    pub unit_price: Uint128,
    pub name: String,
    pub symbol: String,
    pub token_uri: String,
    pub extension: Extension,
    pub unused_token_id: u32,
}

// ...
```

Now let's break down what each attribute on the `Config` struct is:

- `owner` specifies which account is the owner of the contract.
- `cw20_address` contains the address of which cw20 token contract used as a payment method. We will use the contract deployed in the previous tutorial.
- `cw721_address` specifies the address of the cw721 token contract we will use. But the cw721 is created dynamically during contract instantiation, so there's no need to instantiate a cw721 token contract separately.
- `max_tokens` will be the maximum mint token amount of this contract.
- `unit_price` is the unit price for each NFT.
- The `name`, `symbol`, `token_uri`, `extension` fields specify the NFT token info and metadata. Here, the `extension` is of type `cw721_base::Extension`. So you need to add a line like the following in the declaration of the library used by Rust.

  ```rust
  use cw721_base::Extension;
  ```

  We also need to declare the use of `cw721-base` as a dependency in Cargo.toml. Open `Cargo.toml` and add this to the dependencies:

  ```rust cargo.toml focus=3:4
  # ...

  [dependencies]
  cw721-base = { version = "0.15.0", features = ["library"] }
  cw-utils = "0.12.1"

  # ...
  ```

- `unused_token_id` is used to store the total number of NFT tokens have been minted. The reason it is named 'unused_token_id' is because, when executing the mint action, the NFT token will be assigned a token_id equal to the value of the current 'unused_token_id'.

Alright, that's all we are gonna need for the `state.rs` file for now. In the next section we will begin working on the `contract.rs` file.

:::note disclaimer
If you run `cargo test` or `cargo wasm` the build will break! Don't worry, this is expected as we have modified our storage code without changing code on the contract side. We will fix this in the next section.
:::
